---
title: "Analiza danych"
author: "Czarnoksiężnicy z Oz"
date: Opublikowane `r format(Sys.time(), "%A %d %B %Y")`
---

## Dane

```{r}
dane <- read.csv("DanePoprawione.csv", header = TRUE, stringsAsFactors = TRUE)
View(dane)
dane <- as.data.frame(dane)
dane$Loan_Amount_Term <- as.factor(dane$Loan_Amount_Term)
```

## 1. Jednowymiarowa analiza danych

### Autor: Mikołaj Zalewski

```{r}
library(ggplot2)
library(dplyr)
library(tidyr)
num_vars <- c("ApplicantIncome", "CoapplicantIncome", "LoanAmount", "TotalIncome", "DebtToIncomeRatio")
num_dane_long <- dane %>%
  select(all_of(num_vars)) %>%
  pivot_longer(cols = everything(), names_to = "Zmienne", values_to = "Wartość")

ggplot(num_dane_long, aes(x = Wartość, fill = Zmienne)) +
  geom_histogram(bins = 30, alpha = 0.7, color = "black") +
  facet_wrap(~Zmienne, scales = "free") +
  theme_minimal() +
  labs(title = "Histogramy zmiennych numerycznych")

ggplot(num_dane_long, aes(x = Zmienne, y = Wartość, fill = Zmienne)) +
  geom_boxplot() +
  coord_flip() +
  theme_minimal() +
  labs(title = "Boxploty zmiennych numerycznych")

cat_vars <- c("Gender", "Married", "Dependents", "Education", "Self_Employed", "Loan_Amount_Term", "Credit_History", "Property_Area", "Loan_Status")

dane_cat_long <- dane %>%
  select(all_of(cat_vars)) %>%
  pivot_longer(cols = everything(), names_to = "Zmienna", values_to = "Kategoria")

ggplot(dane_cat_long, aes(x = Kategoria, fill = Kategoria)) +
  geom_bar() +
  facet_wrap(~Zmienna, scales = "free") +  # Każda zmienna kategoryczna na osobnym panelu
  theme_minimal() +
  labs(title = "Wykresy częstości dla zmiennych kategorycznych", x = "Kategoria", y = "Liczność")

summary(dane$ApplicantIncome)
summary(dane$CoapplicantIncome)
summary(dane$LoanAmount)
summary(dane$TotalIncome)
summary(dane$DebtToIncomeRatio)
```

## 2. Dwuwymiarowa analiza danych

### Autor: Dominika Szymczak

#### Dwuwymiarowa analiza danych jakościowych:

-   Loan Status vs Gender

```{r}
library(mosaic)
library(knitr)
library(ggplot2)

wykres_gr <- scale_fill_gradientn(colors = c("#42cec2", "#306591", "#002185", "#0f225f", "#142c45"))

# Tworzenie tabeli krzyżowej między Loan_Status i Gender
LoanStatus_vs_Gender <- table(dane$Loan_Status, dane$Gender)
kable(LoanStatus_vs_Gender, caption = "Tabela krzyżowa: Loan Status vs Gender")

# Tworzenie wykresu mozaikowego
mosaicplot(LoanStatus_vs_Gender, shade = TRUE, legend = TRUE, main = "Wykres Mozaikowy: Loan_Status vs Gender")

# Tworzenie wykresu ilościowego
library(colorspace)
ggplot(as.data.frame(LoanStatus_vs_Gender), aes(Var1, Var2, fill = Freq)) +
  geom_tile() +
  theme_minimal() +
  labs(x = "Loan Status", y = "Gender", fill = "ilość") +
  wykres_gr

```

-   Loan Status vs Married

```{r}
# Tworzenie tabeli krzyżowej między Loan_Status i Married
LoanStatus_vs_Married <- table(dane$Loan_Status, dane$Married)
kable(LoanStatus_vs_Married, caption = "Tabela krzyżowa: Loan Status vs Married")

# Tworzenie wykresu mozaikowego
mosaicplot(LoanStatus_vs_Married, shade = TRUE, legend = TRUE, main = "Wykres Mozaikowy: Loan_Status vs Married", col=c("#42cec2", "#306591", "#002185", "#0f225f", "#142c45"))

# Tworzenie wykresu ilościowego
ggplot(as.data.frame(LoanStatus_vs_Married), aes(Var1, Var2, fill = Freq)) +
  geom_tile() +
  theme_minimal() +
  labs(x = "Loan Status", y = "Married") +
  wykres_gr

```

-   Loan Status vs Dependents

```{r}
# Tworzenie tabeli krzyżowej między Loan_Status i Dependents
LoanStatus_vs_Dependents <- table(dane$Loan_Status, dane$Dependents)
kable(LoanStatus_vs_Dependents, caption = "Tabela krzyżowa: Loan Status vs Dependents")

# Tworzenie wykresu mozaikowego
mosaicplot(LoanStatus_vs_Dependents, shade = TRUE, legend = TRUE, main = "Wykres Mozaikowy: Loan_Status vs Dependents")

# Tworzenie wykresu ilościowego
ggplot(as.data.frame(LoanStatus_vs_Dependents), aes(Var1, Var2, fill = Freq)) +
  geom_tile() +
  theme_minimal() +
  labs(x = "Loan Status", y = "Dependents") +
  wykres_gr

```

-   Loan Status vs Education

```{r}
# Tworzenie tabeli krzyżowej między Loan_Status i Education
LoanStatus_vs_Education <- table(dane$Loan_Status, dane$Education)
kable(LoanStatus_vs_Education, caption = "Tabela krzyżowa: Loan Status vs Education")

# Tworzenie wykresu mozaikowego
mosaicplot(LoanStatus_vs_Education, shade = TRUE, legend = TRUE, main = "Wykres Mozaikowy: Loan_Status vs Education")

# Tworzenie wykresu ilościowego
ggplot(as.data.frame(LoanStatus_vs_Education), aes(Var1, Var2, fill = Freq)) +
  geom_tile() +
  theme_minimal() +
  labs(x = "Loan Status", y = "Education") +
  wykres_gr

```

-   Loan Status vs Self_Employed

```{r}
# Tworzenie tabeli krzyżowej między Loan_Status i Self_Employed
LoanStatus_vs_SelfEmployed <- table(dane$Loan_Status, dane$Self_Employed)
kable(LoanStatus_vs_SelfEmployed, caption = "Tabela krzyżowa: Loan Status vs Self Employed")

# Tworzenie wykresu mozaikowego
mosaicplot(LoanStatus_vs_SelfEmployed, shade = TRUE, legend = TRUE, main = "Wykres Mozaikowy: Loan_Status vs Self_Employed")

# Tworzenie wykresu ilościowego
ggplot(as.data.frame(LoanStatus_vs_SelfEmployed), aes(Var1, Var2, fill = Freq)) +
  geom_tile() +
  theme_minimal() +
  labs(x = "Loan Status", y = "Self Employed") +
  wykres_gr

```

-   Loan Status vs Credit History

```{r}
# Tworzenie tabeli krzyżowej między Loan_Status i Credit_History
LoanStatus_vs_CreditHistory <- table(dane$Loan_Status, dane$Credit_History)
kable(LoanStatus_vs_CreditHistory, caption = "Tabela krzyżowa: Loan Status vs Credit History")

# Tworzenie wykresu mozaikowego
mosaicplot(LoanStatus_vs_CreditHistory, shade = TRUE, legend = TRUE, main = "Wykres Mozaikowy: Loan_Status vs Credit_History")

# Tworzenie wykresu ilościowego
ggplot(as.data.frame(LoanStatus_vs_CreditHistory), aes(Var1, Var2, fill = Freq)) +
  geom_tile() +
  theme_minimal() +
  labs(x = "Loan Status", y = "Credit History") +
  wykres_gr

```

-   Loan Status vs Property Area

```{r}
# Tworzenie tabeli krzyżowej między Loan_Status i Property_Area
LoanStatus_vs_PropertyArea <- table(dane$Loan_Status, dane$Property_Area)
kable(LoanStatus_vs_PropertyArea, caption = "Tabela krzyżowa: Loan Status vs Property Area")

# Tworzenie wykresu mozaikowego
mosaicplot(LoanStatus_vs_PropertyArea, shade = TRUE, legend = TRUE, main = "Wykres Mozaikowy: Loan_Status vs Property_Area")

# Tworzenie wykresu ilościowego
ggplot(as.data.frame(LoanStatus_vs_PropertyArea), aes(Var1, Var2, fill = Freq)) +
  geom_tile() +
  theme_minimal() +
  labs(x = "Loan Status", y = "Property Area") +
  wykres_gr

```

#### Dwuwymiarowa analiza danych mieszanych (jakościowej z ilościową)

-   Loan Status vs Applicant Income

```{r}
# Wykres ramka-wąsy (boxplot)
boxplot(dane$log_ApplicantIncome ~ dane$Loan_Status,
        main = "Rozkład dochodów aplikanta według statusu pożyczki",
        xlab = "Loan Status",
        ylab = "Applicant Income",
        col = c("#42cec2", "#002185"),
        notch = TRUE)

# Zamiana Loan_Status na wartości numeryczne
dane$Loan_Status_numeric <- ifelse(dane$Loan_Status == "Yes", 1, 0)
# Obliczenie współczynnika korelacji Pearsona
pearson_corr1 <- cor(dane$Loan_Status_numeric, dane$log_ApplicantIncome, use = "complete.obs")
print(paste("Współczynnik korelacji Pearsona:", pearson_corr1))

# Wykres punktowy
ggplot(dane, aes(x = Loan_Status, y = log_ApplicantIncome, fill = Loan_Status)) +
  geom_jitter(aes(color = Loan_Status), width = 0.2, height = 0, alpha = 0.6) +
  geom_boxplot(alpha = 0.5, outlier.shape = NA) +
  scale_fill_manual(values = c("No" = "#42cec2", "Yes" = "#002185")) + 
  scale_color_manual(values = c("No" = "#002246", "Yes" = "#002246")) +
  labs(title = "Dochody aplikanta w podziale na status kredytu",
       x = "Loan Status",
       y = "Applicant Income") +
  theme_minimal()

```

-   Loan Status vs Loan Amount

```{r}
# Wykres ramka-wąsy (boxplot)
boxplot(dane$log_LoanAmount ~ dane$Loan_Status,
        main = "Rozkład wielkości pożyczki według statusu pożyczki",
        xlab = "Loan Status",
        ylab = "Loan Amount",
        col = c("#42cec2", "#002185"),
        notch = TRUE)

# Obliczenie współczynnika korelacji Pearsona
pearson_corr2 <- cor(dane$Loan_Status_numeric, dane$log_LoanAmount, use = "complete.obs")
print(paste("Współczynnik korelacji Pearsona:", pearson_corr2))

# Wykres punktowy
ggplot(dane, aes(x = Loan_Status, y = log_LoanAmount, fill = Loan_Status)) +
  geom_jitter(aes(color = Loan_Status), width = 0.2, height = 0, alpha = 0.6) +
  geom_boxplot(alpha = 0.5, outlier.shape = NA) +
  scale_fill_manual(values = c("No" = "#42cec2", "Yes" = "#002185")) + 
  scale_color_manual(values = c("No" = "#002246", "Yes" = "#002246")) +
  labs(title = "Kwota kredytu w podziale na status kredytu",
       x = "Loan Status",
       y = "Loan Amount") +
  theme_minimal()

```

-   Loan Status vs Total Income

```{r}
# Wykres ramka-wąsy (boxplot)
boxplot(dane$log_TotalIncome ~ dane$Loan_Status,
        main = "Rozkład całkowitego dochodu według statusu pożyczki",
        xlab = "Loan Status",
        ylab = "Tota lIncome",
        col = c("#42cec2", "#002185"),
        notch = TRUE)

# Obliczenie współczynnika korelacji Pearsona
pearson_corr3 <- cor(dane$Loan_Status_numeric, dane$log_TotalIncome, use = "complete.obs")
print(paste("Współczynnik korelacji Pearsona:", pearson_corr3))

# Wykres punktowy
ggplot(dane, aes(x = Loan_Status, y = log_TotalIncome, fill = Loan_Status)) +
  geom_jitter(aes(color = Loan_Status), width = 0.2, height = 0, alpha = 0.6) +
  geom_boxplot(alpha = 0.5, outlier.shape = NA) +
  scale_fill_manual(values = c("No" = "#42cec2", "Yes" = "#002185")) + 
  scale_color_manual(values = c("No" = "#002246", "Yes" = "#002246")) +
  labs(title = "Całkowite dochody w podziale na status kredytu",
       x = "Loan Status",
       y = "Total Income") +
  theme_minimal()

```

-   Loan Status vs DebtToIncomeRatio

```{r}
# Wykres ramka-wąsy (boxplot)
boxplot(dane$log_DebtToIncomeRatio ~ dane$Loan_Status,
        main = "Rozkład współczynnika długu do przychodów według statusu pożyczki",
        xlab = "Loan Status",
        ylab = "Debt To Income Ratio",
        col = c("#42cec2", "#002185"),
        notch = TRUE)

# Obliczenie współczynnika korelacji Pearsona
pearson_corr3 <- cor(dane$Loan_Status_numeric, dane$log_DebtToIncomeRatio, use = "complete.obs")
print(paste("Współczynnik korelacji Pearsona:", pearson_corr3))

# Wykres punktowy
ggplot(dane, aes(x = Loan_Status, y = log_DebtToIncomeRatio, fill = Loan_Status)) +
  geom_jitter(aes(color = Loan_Status), width = 0.2, height = 0, alpha = 0.6) +
  geom_boxplot(alpha = 0.5, outlier.shape = NA) +
  scale_fill_manual(values = c("No" = "#42cec2", "Yes" = "#002185")) + 
  scale_color_manual(values = c("No" = "#002246", "Yes" = "#002246")) +
  labs(title = "Współczynnik długu do przychodów w podziale na status kredytu",
       x = "Loan Status",
       y = "Debt To Income Ratio") +
  theme_minimal()

```

-   Loan Status vs Loan Amount Term

```{r}
# Wykres ramka-wąsy (boxplot)
boxplot(dane$Loan_Amount_Term ~ dane$Loan_Status,
        main = "Rozkład czasu trwania kredytu według statusu pożyczki",
        xlab = "Loan Status",
        ylab = "Applicant Income",
        col = c("#42cec2", "#002185"),
        notch = TRUE)

# Zamiana Loan_Status na wartości numeryczne
dane$Loan_Status_numeric <- ifelse(dane$Loan_Status == "Yes", 1, 0)
# Obliczenie współczynnika korelacji Pearsona
pearson_corr4 <- cor(dane$Loan_Status_numeric, dane$Loan_Amount_Term, use = "complete.obs")
print(paste("Współczynnik korelacji Pearsona:", pearson_corr4))

# Wykres punktowy
ggplot(dane, aes(x = Loan_Status, y = Loan_Amount_Term, fill = Loan_Status)) +
  geom_jitter(aes(color = Loan_Status), width = 0.2, height = 0, alpha = 0.6) +
  geom_boxplot(alpha = 0.5, outlier.shape = NA) +
  scale_fill_manual(values = c("No" = "#42cec2", "Yes" = "#002185")) + 
  scale_color_manual(values = c("No" = "#002246", "Yes" = "#002246")) +
  labs(title = "Czas trwania kredytu w podziale na status kredytu",
       x = "Loan Status",
       y = "Loan Amount Term") +
  theme_minimal()

```
W ramach analizy dwuwymiarowej przeanalizowano zależności między zmiennymi, szczególną uwagę zwracając na zmienne o najwyższych współczynnikach korelacji oraz te, które mają istotne znaczenie dla analizy ryzyka kredytowego.

Najwyższe wartości współczynnika korelacji zaobserwowano dla zmiennych:
- Credit History – silnie skorelowana z przyznawalnością kredytu, co wskazuje na kluczową rolę historii kredytowej w procesie oceny wniosku. Klienci posiadający historię kredytową mają wyższe szanse na uzyskanie kredytu.
- Loan Amount Term – długość okresu kredytowania wykazuje istotny związek z decyzją kredytową, najczęściej akceptowane są kreydyty zaciągane na okres 30 lat.
- Property Area – obszar nieruchomości również wpływa na decyzję o przyznaniu kredytu. Najczęściej kredyty są akceptowane dla mieszkańców terenów podmiejskich, rzadziej dla mieszkańców miasta oras okolic wiejskich.

W analizie, również ważnymi czynnikami są:
- Total Income – łączny dochód wnioskodawcy odgrywa kluczową rolę w ocenie zdolności kredytowej. Wyższe dochody zwiększają prawdopodobieństwo uzyskania pozytywnej decyzji kredytowej.
- Debt To Income Rate – wskaźnik zadłużenia w stosunku do dochodu jest istotnym miernikiem ryzyka. Wyższa wartość tego wskaźnika może sugerować większe obciążenie finansowe, co może negatywnie wpłynąć na decyzję kredytową.

## 3. Budowanie i testowanie hipotez

### AUtor: Julia Sowińska

Dla wszystkich postawionych hipotez, przyjmuje się poziom istotności alpha w wysokości 0,05 (5%).

### Hipotezy:

#### A. Loan_Status i Credit_History

H₀: Prawdopodobieństwo przyznania kredytu (Loan_Status) jest niezależne od posiadania historii kredytowej (Credit_History).
H₁: Prawdopodobieństwo przyznania kredytu różni się w zależności od posiadania historii kredytowej.

```{r}
print("Tabela krzyżowa:")
print(LoanStatus_vs_CreditHistory)
```

Założenie o minimalnej liczbie oczekiwanych obserwacji w każdej komórce tabeli kontyngencji, która powinna wynosić co najmniej 5 (założenie testu chi-kwadrat), jest spełnione, dlatego zostanie wykorzystany test Chi-kwadrat.

```{r}
library(ggstatsplot)
chi_kwadrat <- chisq.test(LoanStatus_vs_CreditHistory)
print(chi_kwadrat)
ggbarstats(data = dane, x = Credit_History, y = Loan_Status)
```

P-value jest mniejsze niż przyjęty poziom istotności, co pozwala odrzucić hipotezę zerową i przyjąć hipotezę alternatywną o istnieniu zależności między zmiennymi Loan_Status i Credit_History.

```{r}
# Współczynnik Craméra
n <- sum(LoanStatus_vs_CreditHistory)
phi_cramer <- sqrt(chi_kwadrat$statistic / (n * (min(dim(LoanStatus_vs_CreditHistory)) - 1)))
names(phi_cramer) <- "Cramer's V"
print(phi_cramer)
```

Współczynnik Cramera przyjmuje wartość w przybliżeniu 0,428, co świadczy o umiarkowanym związku między zmiennymi Loan_Status i Credit_History.

#### B. Loan_Status i Loan_Amount_Term

H₀: Długość okresu spłaty kredytu (Loan_Amount_Term) nie wpływa na decyzję o przyznaniu kredytu.
H₁: Długość okresu spłaty kredytu wpływa na decyzję o przyznaniu kredytu.

```{r}
LoanStatus_vs_Loan_Amount_Term <- table(dane$Loan_Status, dane$Loan_Amount_Term)
print("Tabela krzyżowa:")
print(LoanStatus_vs_Loan_Amount_Term)
```

Założenie o minimalnej liczbie oczekiwanych obserwacji w każdej komórce tabeli kontyngencji, która powinna wynosić co najmniej 5 (założenie testu chi-kwadrat), nie jest spełnione, więc wykorzystany zostanie test Fishera.

```{r}
fisher_test <- fisher.test(LoanStatus_vs_Loan_Amount_Term)
print(fisher_test)
ggbarstats(data = dane, x = Loan_Amount_Term, y = Loan_Status, test = "fisher")
```

P-value jest większe niż przyjęty poziom istotności, co oznacza brak podstaw do odrzucenia hipotezy zerowej o braku zależności między zmiennymi Loan_Status i Loan_Amount_Term.

#### C. Loan_Status i Property_Area

H₀: Obszar zamieszkania kredytobiorcy (Property_Area) nie wpływa na decyzję o przyznaniu kredytu.
H₁: Obszar zamieszkania kredytobiorcy wpływa na decyzję o przyznaniu kredytu.

```{r}
print("Tabela krzyżowa:")
print(LoanStatus_vs_Property_Area)
```

Założenie o minimalnej liczbie oczekiwanych obserwacji w każdej komórce tabeli kontyngencji, która powinna wynosić co najmniej 5 (założenie testu chi-kwadrat), jest spełnione, dlatego zostanie wykorzystany test Chi-kwadrat.

```{r}
# Test chi-kwadrat
chi_kwadrat <- chisq.test(LoanStatus_vs_PropertyArea)
print(chi_kwadrat)
ggbarstats(data = dane, x = Property_Area, y = Loan_Status)
```

P-value jest mniejsze niż przyjęty poziom istotności, co pozwala odrzucić hipotezę zerową i przyjąć hipotezę alternatywną o istnieniu zależności między zmiennymi Loan_Status i Property_Area.

```{r}
# Współczynnik Craméra
n <- sum(LoanStatus_vs_PropertyArea)
phi_cramer <- sqrt(chi_kwadrat$statistic / (n * (min(dim(LoanStatus_vs_PropertyArea)) - 1)))
names(phi_cramer) <- "Cramer's V"
print(phi_cramer)
```

Współczynnik Cramera przyjmuje wartość w przybliżeniu 0,142, co świadczy o słabym związku między zmiennymi Loan_Status i PropertyArea.

#### D. Loan_Status i log_DebtToIncomeRatio

H₀: Średni wskaźnik długu do dochodu (DebtToIncomeRatio) nie różni się między grupami, którym przyznano i nie przyznano kredytu.
H₁: Średni wskaźnik długu do dochodu różni się między grupami, którym przyznano i nie przyznano kredytu.

```{r}
group_yes <- dane$log_DebtToIncomeRatio[dane$Loan_Status == "Yes"]
group_no <- dane$log_DebtToIncomeRatio[dane$Loan_Status == "No"]

# Test Shapiro-Wilka dla normalności
shapiro_yes <- shapiro.test(group_yes)
shapiro_no <- shapiro.test(group_no)

cat("Group Yes: W =", shapiro_yes$statistic, ", p =", shapiro_yes$p.value, "\n")
cat("Group No: W =", shapiro_no$statistic, ", p =", shapiro_no$p.value, "\n")

# Test Bartletta dla jednorodności wariancji
bartlett_test <- bartlett.test(DebtToIncomeRatio ~ Loan_Status, data = dane)
print(bartlett_test)
```

Zarówno założenie o normalności rozkładu zmiennej log_DebtToIncomeRatio w każdej z grup Loan_Status (Yes/No), jak i założenie o jednorodności wariancji nie zostały spełnione, dlatego zamiast testu t-Studenta, stosowany będzie test U Manna-Whitneya.

```{r}
mannwhitney <- wilcox.test(log_DebtToIncomeRatio ~ Loan_Status, data = dane)
  print(mannwhitney)
gghistostats(data = dane, x = log_DebtToIncomeRatio, y = Loan_Status)
```

P-value jest większe niż przyjęty poziom istotności, co oznacza brak podstaw do odrzucenia hipotezy zerowej o braku zależności między zmiennymi Loan_Status i DebtToIncomeRatio.

#### E. Loan_Status i log_TotalIncome

H₀: Średni całkowity dochód (TotalIncome) nie różni się między grupami, którym przyznano i nie przyznano kredytu.
H₁: Średni całkowity dochód różni się między grupami, którym przyznano i nie przyznano kredytu.

```{r}
group_yes <- dane$log_TotalIncome[dane$Loan_Status == "Yes"]
group_no <- dane$log_TotalIncome[dane$Loan_Status == "No"]

# Test Shapiro-Wilka dla normalności
shapiro_yes <- shapiro.test(group_yes)
shapiro_no <- shapiro.test(group_no)

cat("Group Yes: W =", shapiro_yes$statistic, ", p =", shapiro_yes$p.value, "\n")
cat("Group No: W =", shapiro_no$statistic, ", p =", shapiro_no$p.value, "\n")

# Test Bartletta dla jednorodności wariancji
bartlett_test <- bartlett.test(log_TotalIncome ~ Loan_Status, data = dane)
print(bartlett_test)
```

Zarówno założenie o normalności rozkładu zmiennej log_DebtToIncomeRatio w każdej z grup Loan_Status (Yes/No), jak i założenie o jednorodności wariancji nie zostały spełnione, dlatego zamiast testu t-Studenta, stosowany będzie test U Manna-Whitneya.

```{r}
mannwhitney <- wilcox.test(log_TotalIncome ~ Loan_Status, data = dane)
  print(mannwhitney)
gghistostats(data = dane, x = log_TotalIncome, y = Loan_Status)
```

P-value jest większe niż przyjęty poziom istotności, co oznacza brak podstaw do odrzucenia hipotezy zerowej o braku zależności między zmiennymi Loan_Status i TotalIncome

Zależność zmiennych Credit_History oraz Property_Area ze zmienną Loan_Status zostały uznane za istotne.

## 4. Grupy klientów według kombinacji Credit_History i Property_Area
### Autor: Mikołaj Zalewski

### Dodanie nowej zmiennej grupującej klientów według Credit_History i Property_Area na 6 grup

```{r}
dane$Group <- paste(dane$Property_Area, dane$Credit_History, sep = "_")
dane$Group <- factor(dane$Group,
                          levels = c("Urban_Existing", "Semiurban_Existing", "Rural_Existing", "Urban_Not existing", "Semiurban_Not existing", "Rural_Not existing"),
                          labels = c("Urban_Existing", "Semiurban_Existing", "Rural_Existing", "Urban_Not existing", "Semiurban_Not existing", "Rural_Not existing"))
```

### Skrócone statystyki opisowe dla każdej grupy
``` {r}
statystyki <- dane %>%
  group_by(Group) %>%
  summarise(
    Liczba_osob = n(),
    Procent_mezczyzn = (sum(Gender == "Male", na.rm = TRUE) / Liczba_osob) * 100,
    Procent_married = (sum(Married == "Yes", na.rm = TRUE) / Liczba_osob) * 100,
    Procent_Graduate = (sum(Education == "Graduate", na.rm = TRUE) / Liczba_osob) * 100,
    Srednia_TotalIncome = mean(TotalIncome, na.rm = TRUE)
  )

statystyki
## w tych grupach procent mężczyzn największy to 88 w rural not existing a najmniejszy to 67 w semiurban not existing 
## w tych grupach różnica między największą wartością a najmniejszą jeśli chodzi o bycie żonatym/zamężnym wynosi 11,8 punkta procentowego
## Pośród tych grup srednia maksymalna wartośc zmiennej total income różni się od minilanej wartości w o 1500
```

### Proporcje przyznanych kredytów w każdej grupie
``` {r}
proporcje_loan_status <- dane %>%
  group_by(Group, Loan_Status) %>%
  summarise(Liczba = n(), .groups = "drop") %>%
  group_by(Group) %>%
  mutate(Proporcja = Liczba / sum(Liczba) * 100)

ggplot(proporcje_loan_status, aes(x = "", y = Proporcja, fill = Loan_Status)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar(theta = "y") + 
  facet_wrap(~ Group) +  
  theme_void() +  
  labs(title = "Proporcja osób, które otrzymały kredyt w każdej grupie") +
  scale_fill_manual(values = c("green", "red")) +  # Kolory dla 'Loan_Status'
  geom_text(aes(label = paste0(round(Proporcja, 1), "%")), position = position_stack(vjust = 0.5), color = "white")  # Dodanie procentów na wykresach

```


## 5. Model predykcyjny
### Autor: Julia Sowińska

### Podział danych na zbiór treningowy i testowy

```{r}
dane$Loan_Status_Binary <- dane$Loan_Status_numeric
set.seed(123)
train_idx <- sample(1:nrow(dane), 0.7 * nrow(dane))
train <- dane[train_idx, ]
test <- dane[-train_idx, ]
```

Dane zostały podzielona na dwa zbiory - treningowy i testowy, by uniknąć przeuczenia (overfittingu) oraz zapewnić rzetelną ocenę modelu poprzez testowanie modelu na danych, których nie widział podczas treningu.
Zdecydowano się na podział: 70% danych do treningu i 30% danych do testu.

### Budowa modelu

```{r}
model <- glm(Loan_Status_Binary ~ Credit_History + Property_Area, data = train, family = "binomial")
summary(model)
```

Zbudowany został model regresji logistycznej (logit), który był naturalnym wyborem dla problemu klasyfikacji binarnej, jakim było przyznanie bądź nieprzyznanie kredytu.
Model ten został wybrany ze względu na jego prostotę, szybkość i efektywność, a także ze względu na łatwiejszą interpretację.
Jest to model predykcyjny, zatem zdecydowano się na pozostawienie w nim wszystkich zmiennych bez względu na istotność statystyczną.

### Ocena modelu

```{r}
predictions <- predict(model, newdata = test, type = "response")
predicted_classes <- ifelse(predictions > 0.5, "Yes", "No")
confusion_matrix <- table(Predicted = predicted_classes, Actual = test$Loan_Status)
print(confusion_matrix)

confusion_matrix_df <- as.data.frame(confusion_matrix)
ggplot(confusion_matrix_df, aes(Actual, Predicted, fill = Freq)) +
  geom_tile() +
  theme_minimal() +
  labs(x = "Rzeczywista klasa", y = "Przewidywana klasa", fill = "Liczba")

accuracy <- sum(diag(confusion_matrix)) / sum(confusion_matrix)
cat("Dokładność:", accuracy, "\n")
precision <- confusion_matrix["Yes", "Yes"] / (confusion_matrix["Yes", "Yes"] + confusion_matrix["No", "Yes"])
cat("Precyzja:", precision, "\n")
recall <- confusion_matrix["Yes", "Yes"] / (confusion_matrix["Yes", "Yes"] + confusion_matrix["Yes", "No"])
cat("Czułość:", recall, "\n")

f1_score <- 2 * (precision * recall) / (precision + recall)
cat("F1-score:", f1_score, "\n")
```

Model prawidłowo klasyfikuje około 75,68% przypadków.
Około 88,46% przewidywań przyznania kredytu jest prawidłowe i około 79,31% rzeczywistych przyznań kredytu zostało poprawnie wykrytych.

F1 Interpretacja:
Blisko 1 → Model świetnie klasyfikuje obie klasy.
Blisko 0 → Model źle rozróżnia klasy (np. zawsze przewiduje tylko "Yes").
Przykład: F1-score = 0.85 oznacza, że model jest dobrze wyważony między precyzją a czułością.

```{r}
library(pROC)
roc_curve <- roc(test$Loan_Status, predictions)
plot(roc_curve, col = "blue")
auc(roc_curve)
```

AUC przyjmuje wartość 0,7614, co oznacza, że model jest przyzwoity.

### Wypróbowanie drzewa decyzyjnego
``` {r}
library(rpart)
library(rpart.plot)

tree_model <- rpart(Loan_Status ~ Credit_History + Property_Area, data = dane, method = "class")

rpart.plot(tree_model)
```

```{r}
tree_preds <- predict(tree_model, newdata = test, type = "class")
# Macierz konfuzji
tree_conf_matrix <- table(Predicted = tree_preds, Actual = test$Loan_Status)
# Dokładność
tree_accuracy <- sum(diag(tree_conf_matrix)) / sum(tree_conf_matrix)
cat("Decision Tree Accuracy:", tree_accuracy, "\n")
```
Accuracy jest praktycznie taka sama, więc lepiej użyć prostrzego modelu - logitu.

## 6. Podsumowanie
### Autor: Dominika Szymczak

